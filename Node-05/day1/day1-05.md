# NodeJS

## 前端

> 前端运行JS的条件

在以前如果你需要运行一份JS，你写完这份`index.js`之后需要一份`index.html`利用`<script>`标签引入，并且在浏览器中打开该页面执行对应的代码

- 必须需要html `<script>`
- 浏览器

> 后端运行JS的条件

我不需要`html`和`css`

- 浏览器的环境

把浏览器运行JS的控制台(Chrome V8 引擎)挖了出来，单独安装到系统上，只给JS服务。从而抛弃`html`和`css`

Node的本质就是Chrome的控制台，只服务JS。JS从前端“退化”进后端，JS想专心去干一件事件，不是为前端服务，就是为了证明自己。



## 下载 && 安装

根据你的电脑系统去下载对应的版本，[官方下载地址](http://nodejs.cn/download/)

检查是否安装成功，如果安装成功在命令行里面可以用以下两个指令查看到版本

<img src="1.png" />
<img src="2.png" />


# 运行NodeJS的脚本

现在既然引擎已经安装在系统上，那么我们可以利用该系统的命令行唤醒node命令，执行对应的JS脚本。

```bash
node index.js
# 可以省略后缀
node index
```

# 模块化

把一个很复杂的逻辑，分开去写，比如写轮播图的我就用一份`swiper.js`，比如封装DOM的操作`jquery.js`，分模块完成任务，

- 方便维护
- 方便找问题
- 方便团队开发
- 逻辑解耦

Node把html和css抛弃了，`<script>`模块化的方案不适用了

```html
<script src="jquery.js"></script>
<script src="swiper.js"></script>
```

- `<script>`
- require.js CMD规范   require('./xxx') define('xxxx')
- sea.js AMD规范  require()
- comonon.js规范 Node
- ES6 import和export

导入使用`require`关键词
```js
// 导入一个函数
const module2 = require('./module2.js')
const fn = require('./fn.js')
console.log(1)
module2()
console.log(fn.arr)
// 代替script的模块化规范
```

导出用`module.exports`关键词
```js
module.exports = {
    arr: [1, 2, 3],
    bool: !0,
    plus(a, b) {
        return a + b
    }
}
```